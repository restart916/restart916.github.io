---
title: Leetcode 771. Jewels and Stones
excerpt: Leetcode 771. Jewels and Stones 문제를 풀면서 고생한 내용입니다.
image: "./images/leetcode_771.jpg"
date: 2019-06-15

meta:
  - property: og:title
    content: Wally Lee Dev Blog - Leetcode 771. Jewels and Stones
  - property: og:description
    content: Wally Lee Dev Blog - Leetcode 771. Jewels and Stones 문제를 풀면서 고생한 내용입니다.
  - property: og:image
    content: https://restart916.github.io/upload/leetcode_771.jpg
---

[https://leetcode.com/problems/jewels-and-stones/](https://leetcode.com/problems/jewels-and-stones/)

주어진 문자열S와 찾고싶은 문자J가 있으면 매칭되는 글자 수를 세는 문제입니다.

문제를 풀때 다양한 알고리즘이나 풀이법을 고민할수도 있지만 먼저 단순하게 풀이(Brute Force)가 가능하면 그 방법으로 먼저 풀어보는것을 추천합니다.

그럼 주어진 전체 문자열에 대해 하나하나 다 비교해보면서 갯수를 세는 단순한 풀이를 먼저 적용해보겠습니다.
(easy 라고 막 풀었다가 나중에 큰코를 다치게 됩니다.)


## Brute Force 로 풀기

```js
/**
 * @param {string} J
 * @param {string} S
 * @return {number}
 */
var numJewelsInStones = function(J, S) {
    let count = 0
    for (let j of J) {
      for (let s of S) {
            if (j == s) {
                count++;
            }
        }
    }

    return count;
};
```

Submit! 제출을 하면 코드가 무사히 돌아가고 통과했다는 결과를 받았습니다. 통과 했다는건 기쁘지만 개선할것이 아직 많습니다.

```
Runtime: 72 ms, faster than 19.92% of JavaScript online submissions for Jewels and Stones.
Memory Usage: 35.6 MB, less than 6.82% of JavaScript online submissions for Jewels and Stones.
```

문제를 풀고나면 나오는 내용인데 속도나 메모리 측면에서 하위 20%에 해당한다는 결과가 나옵니다. 그럼 하나씩 개선을 해보도록 하겠습니다.


## 1차 개선 (했으나..)

첫째로 현재는 전체에 대해 모든 비교를 하고 있습니다. 그런데 한개의 돌s에 대해 주얼인지 비교할때 모든 주얼에 대해 비교를 하는데 첫번째 주얼과 비교해서 보석인게 확인이 되었으면 나머지 보석과는 비교를 안해도 괜찮치 않을까요? 개선도 쉬운것부터 하나씩 개선을 해봅시다.

```js
/**
 * @param {string} J
 * @param {string} S
 * @return {number}
 */
var numJewelsInStones = function(J, S) {
    let count = 0
    for (let s of S) {    // switch for loop
      for (let j of J) {
            if (j == s) {
                count++;
                break;
            }
        }
    }

    return count;
};
```

간단한 변경입니다. 돌 기준으로 검사를 돌려야 해서 for loop 순서를 변경했고 매칭이 되면 나머지 보석에 대해서는 비교를 안하기 위해서 break 문을 추가했습니다.

```
Runtime: 76 ms, faster than 16.82% of JavaScript online submissions for Jewels and Stones.
Memory Usage: 35.6 MB, less than 6.77% of JavaScript online submissions for Jewels and Stones.
```

... 죄송합니다. 결과가 크게 달라지지 않았습니다. 나중에 코딩인터뷰라면 이런 접근은.. 안좋을수도 있겠네요 ㅠㅠ


## 빅오표기법을 생각하자

잠깐 환기를 위해 빅오 표기법을 생각해봅니다. 처음 코드는 O(J*S)가 나옵니다. 보석수와 돌의 수 만큼 루프가 계산되니까요. 두번째 코드도 생각해보면 break 문이 있지만 빅오 표현식에선 영향이 없겠지요? (이부분에 있어서 잘못된 부분이 있담면 알려주세요.) 그럼 이런 개선도 물론 영양가가 없다고 할순 없지만 빅오 표현식이 바뀔정도의 개선은 아닌거 같습니다. 그럼 어떻게 해야 할까요?

빅오식으로 생각하면 개선의 방향을 잡는데도 도움이 됩니다. 저기서 J*S 식으로 표현된것중 하나정돈 log 나 1 로 만들어버려야 합니다.

정렬을 해볼까요? 두 문자가 정렬이 되어있다면 어느 한쪽에서 그 길이가 끝날때까지만 비교하기때문에 엄청 빠르게 할수 있을거 같네요.
아니면 주어진 돌S에 대해 미리 카운트를 세어 놓았다면? 원하는 보석 수만 가져와서 세면 되니 금방 끝날거 같습니다.


## map 을 사용하여 미리 갯수를 세기

```js
/**
 * @param {string} J
 * @param {string} S
 * @return {number}
 */
var numJewelsInStones = function(J, S) {
    let count = 0

    sMap = {}
    for (let s of S) {
        if (s in sMap) {
            sMap[s]++;
        } else {
            sMap[s] = 1;
        }
    }

    for (let j of J) {
        if (j in sMap) {
            count += sMap[j]
        }
    }

    return count;
};
```

먼저 두번째 방법으로 시도를 해보겠습니다. 뭔가 이 글이 문제에 대한 깔끔한 풀이와 설명을 기대하셨다면 조금 죄송합니다. 저도 풀면서 삽질을 한 기록이니 이런게 또 어느분께는 도움이 될까하여 계속 적습니다.

코드를 설명하자면 주어진 돌S에 대해 갯수를 셉니다. 같은 문자s에 대해 카운트를 센 후 원하는 보석J와 매칭이 되는 돌들의 count 만 합해서 결과를 리턴합니다.

간단히보면 더이상 중복 for문이 아니라서 빅오식으로도 O(S)거나 O(J) 둘중 더 큰것(보통 s겠죠?)으로 계산될거 같습니다. 두근두근 제출을 해봅니다.

```
Runtime: 56 ms, faster than 91.06% of JavaScript online submissions for Jewels and Stones.
Memory Usage: 34.4 MB, less than 36.97% of JavaScript online submissions for Jewels and Stones.
```

개선된거 같습니다. 이게 제출할때마다 측정이 조금씩 달라서 확신하긴 조금 애매하네요. 아무튼 생각해보면 속도는 빨라졌지만 이전보다 메모리는 더 사용하게 되었습니다. 기존에 필요없던 sMap을 사용하기 때문이죠.

여기까지만 해도 괜찮은거 같지만 기왕에 쓰게된거 계속 진행해 보겠습니다. 위에 말했던 정렬을 써보겠습니다.


## 정렬을 사용하여 풀이하기

```js
/**
 * @param {string} J
 * @param {string} S
 * @return {number}
 */

var sort = (s) => {
    let arr = []
    for (let c of s) {
        arr.push(c);
    }
    arr.sort();
    return arr;
}

var numJewelsInStones = function(J, S) {
    let count = 0

    J = sort(J);
    S = sort(S);

    let jIndex = 0
    let sIndex = 0

    let j = J[jIndex]
    let s = S[sIndex]

    while(1) {
        if (j == s) {
            count++

            sIndex++
            if (sIndex == S.length) {
                break;
            }

            s = S[sIndex]
        } else {
            if (j > s) {
                sIndex++
                if (sIndex == S.length) {
                    break;
                }

                s = S[sIndex]
            } else {
                jIndex++
                if (jIndex == J.length) {
                    break;
                }

                j = J[jIndex]
            }
        }
    }

    return count;
}
```

두 주어진 문자를 정렬한 후 순서대로 하나씩 비교해가면서 갯수를 세도록 했습니다. 중요한점은 정렬이 되어있기때문에 둘중 한쪽의 비교가 어긋낫을때 반대편을 초기화 시킬필요가 없다는 점입니다. 그래서 두 인덱스가 계속 증가를 하고 어느한쪽의 길이가 다하면 그 지점에서 비교를 종료할 수 있습니다.

빅오표현식으로는 이전 방식과 같게 O(N) (N=S,J둘중 긴것)이라고 생각했으나 앞에 sort를 했던것을 생각하면 nLogn (n=S,J둘중 긴것)이지 않을까 생각해봅니다.


## 정리

1. 무식하게 풀기(BF)가 된다면 바로 풀어볼것을 권장합니다
2. 풀이가 가능하면 이후에 개선을 하..는데
3. 개선전 성능을 측정(빅오표기법)하고 개선을 시작합니다. 현 상태를 파악하면 개선하는데도 도움이 됩니다.
4. 개선하면 다시 측정해보고 더 개선할 지점이 있는지 고민해봅니다.

ps. 공부시에는 한문제에 2시간 이상 소요해서 더이상 개선이 안될때는 적당히 남들의 풀이를 보고 공부하는것도 추천합니다.
